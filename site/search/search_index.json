{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the official documentation for the InvestorID organization . Learn more about InvestorID on the official website .","title":"Home"},{"location":"#home","text":"Welcome to the official documentation for the InvestorID organization . Learn more about InvestorID on the official website .","title":"Home"},{"location":"introduction/","text":"Identity ecosystem for digital assets holders What is InvestorID? InvestorID identities are smart contracts deployed on the BlockChain . Their address is a unique identifier that can safely be used by service provider to identify their owner, and even to sign challenges like direct authentication on a website . Claims can be attached to prove compliance with a tokenized asset requirements. An InvestorID identity allows an investor to truly own its identity, whilst allowing trusted services to emit claims for it. The data associated with the identity and its claims are under the control of the investor who can share them with other service providers. They are fully compatible with every security token based on the T-REX standard (Token for Regulated EXchanges). What should be expected of this documentation? This documentation introduces the concept of a BlockChain Identity, and demonstrate some of its use-case. It also contains the documentation for several tools related to InvestorID Identities such as the Identity SDK .","title":"Introduction"},{"location":"introduction/#identity-ecosystem-for-digital-assets-holders","text":"","title":"Identity ecosystem for digital assets holders"},{"location":"introduction/#what-is-investorid","text":"InvestorID identities are smart contracts deployed on the BlockChain . Their address is a unique identifier that can safely be used by service provider to identify their owner, and even to sign challenges like direct authentication on a website . Claims can be attached to prove compliance with a tokenized asset requirements. An InvestorID identity allows an investor to truly own its identity, whilst allowing trusted services to emit claims for it. The data associated with the identity and its claims are under the control of the investor who can share them with other service providers. They are fully compatible with every security token based on the T-REX standard (Token for Regulated EXchanges).","title":"What is InvestorID?"},{"location":"introduction/#what-should-be-expected-of-this-documentation","text":"This documentation introduces the concept of a BlockChain Identity, and demonstrate some of its use-case. It also contains the documentation for several tools related to InvestorID Identities such as the Identity SDK .","title":"What should be expected of this documentation?"},{"location":"license/","text":"","title":"License"},{"location":"blockchain/core-concepts/","text":"","title":"Main concepts"},{"location":"developers/developers/","text":"Hello, World! Welcome developers! The InvestorID ecosystem comes with many tools and packages you can use to facilitate the integration of blockchain identities with your applications. The Identity SDK helps fetching and verifying information about identities and their claims, adding and managing the claims.","title":"Developers HomePage"},{"location":"developers/developers/#hello-world","text":"Welcome developers! The InvestorID ecosystem comes with many tools and packages you can use to facilitate the integration of blockchain identities with your applications. The Identity SDK helps fetching and verifying information about identities and their claims, adding and managing the claims.","title":"Hello, World!"},{"location":"developers/constants/claim-schemes/","text":"Claim Types These are the list of claim schemes that are standard for InvestorID Identities and some other standards like T-REX. A JSON description of these schemes can be downloaded from the Github repository . Claim Scheme Name Description Example 10101000666002 URL_ENCODED URL Encoded string key_a=VALUE_A&key_b=VALUE_B","title":"Claim Schemes"},{"location":"developers/constants/claim-schemes/#claim-types","text":"These are the list of claim schemes that are standard for InvestorID Identities and some other standards like T-REX. A JSON description of these schemes can be downloaded from the Github repository . Claim Scheme Name Description Example 10101000666002 URL_ENCODED URL Encoded string key_a=VALUE_A&key_b=VALUE_B","title":"Claim Types"},{"location":"developers/constants/claim-types/","text":"Claim Types These are the list of claim types that are standard for InvestorID Identities and some other standards like T-REX. A JSON description of these types, completed with the parsing method description can be downloaded from the Github repository . Claim Type Name Description Scheme Data 10101000042003 FIRST_NAME_CLEAR First name in clear text. URL_ENCODED firstName=VALUE 10101000042004 LAST_NAME_CLEAR Last name in clear text. URL_ENCODED lastName=VALUE","title":"Claim Types"},{"location":"developers/constants/claim-types/#claim-types","text":"These are the list of claim types that are standard for InvestorID Identities and some other standards like T-REX. A JSON description of these types, completed with the parsing method description can be downloaded from the Github repository . Claim Type Name Description Scheme Data 10101000042003 FIRST_NAME_CLEAR First name in clear text. URL_ENCODED firstName=VALUE 10101000042004 LAST_NAME_CLEAR Last name in clear text. URL_ENCODED lastName=VALUE","title":"Claim Types"},{"location":"developers/constants/information-types/","text":"Information Types These are the standard information types for Identity Providers. Information Type Description Scheme email Email STRING firstName First name STRING lastName Last name STRING nationality National (not residential country) STRING","title":"Information Types"},{"location":"developers/constants/information-types/#information-types","text":"These are the standard information types for Identity Providers. Information Type Description Scheme email Email STRING firstName First name STRING lastName Last name STRING nationality National (not residential country) STRING","title":"Information Types"},{"location":"developers/providers/Claim Issuers/get-started/","text":"","title":"Get started"},{"location":"developers/providers/Claim Issuers/presentation/","text":"Introduction to Claim Issuers A Claim Issuer is a service provider that has the technical ability to emit or validate information about an Identity. For instance, Tax offices can validate/emit the tax number of a personn using its identity data. They may require payment in exchange of the checks. Claims can be generic (ID number, tax number, identity check, accreditation status) or specific to a configuration (is the identity owner conform to a set of criteria? Is it arbitrary approved by an issuer?) . Claims usually hold private sensitive data, and these data MUST NOT be accessible publicly. These data should be referenced in the blockchain claim with a hash and unique identifier and uri that allows anyone to access the claim data, provided that the request emitter has the right to access them. As the User is the owner of the data, he/she should be the only one to manage the access rights to these data. Other services may request access from him/her. To be a Claim issuer, a service must be able to generate (or use) one or several private key that will be used to sign the claim issued, and must implement a service to emit transactions on the Identity contract in order to add claims. This is the bare minimum. There are some Claim Issuer SDK which handle the blockchain part after being configured to use the Claim Issuer wallet key and its private claim signing key. Usually, a Claim Issuer awaits an order before emitting a claim, and will probably ask for payment in exchange. You will certainly have to build an API to receive these orders, but you could also manage these via non-automated media like email, phone calls, or whatever you want. If you build an API, this will allow Service Providers and Tokenization Platforms to trigger the checks at an appropriate time. You may also want to notify Identity owner, Token Issuer or Information Provider that you issued a claim. These will usually scan blockchain to detect them, but sending them a notification is appreciated. Most SDK implements standard methods to call these services. Sometimes, claims needs to hold data that cannot be put on the blockchain. The Claim issuer needs to store these private claim data somewhere (digital or not). Some Information Providers allows Claim Issuer to store claim data in their databases. The SDK implements methods to store and retrieve these. You must have the explicit consent of the User in order to share the data with an Information Provider or another service such as a Token Issuer. Some Information Providers handle the access rights management (checking rights, allow the user to manage these rights, ...) . To issue a claim, a Claim Issuer usually has to ask information about the user. It can ask the user for these information. But a user doesn't want to send the same data and fill the same forms each time he wants a claim. Therefore, they may use an Information Provider to keep their information in a single place. Other services may then request these data from the Information Provider, with the explicit consent of the user. Most SDK provides all methods required to request and access these information. Summary Whatever types of claims the service will issue, it must implement the following features: Ability to publish claim on the BlockChain. Manage a Claim Registry on the BlockChain (optional). Manage access grants to data of a claim.","title":"What are they?"},{"location":"developers/providers/Claim Issuers/presentation/#introduction-to-claim-issuers","text":"A Claim Issuer is a service provider that has the technical ability to emit or validate information about an Identity. For instance, Tax offices can validate/emit the tax number of a personn using its identity data. They may require payment in exchange of the checks. Claims can be generic (ID number, tax number, identity check, accreditation status) or specific to a configuration (is the identity owner conform to a set of criteria? Is it arbitrary approved by an issuer?) . Claims usually hold private sensitive data, and these data MUST NOT be accessible publicly. These data should be referenced in the blockchain claim with a hash and unique identifier and uri that allows anyone to access the claim data, provided that the request emitter has the right to access them. As the User is the owner of the data, he/she should be the only one to manage the access rights to these data. Other services may request access from him/her. To be a Claim issuer, a service must be able to generate (or use) one or several private key that will be used to sign the claim issued, and must implement a service to emit transactions on the Identity contract in order to add claims. This is the bare minimum. There are some Claim Issuer SDK which handle the blockchain part after being configured to use the Claim Issuer wallet key and its private claim signing key. Usually, a Claim Issuer awaits an order before emitting a claim, and will probably ask for payment in exchange. You will certainly have to build an API to receive these orders, but you could also manage these via non-automated media like email, phone calls, or whatever you want. If you build an API, this will allow Service Providers and Tokenization Platforms to trigger the checks at an appropriate time. You may also want to notify Identity owner, Token Issuer or Information Provider that you issued a claim. These will usually scan blockchain to detect them, but sending them a notification is appreciated. Most SDK implements standard methods to call these services. Sometimes, claims needs to hold data that cannot be put on the blockchain. The Claim issuer needs to store these private claim data somewhere (digital or not). Some Information Providers allows Claim Issuer to store claim data in their databases. The SDK implements methods to store and retrieve these. You must have the explicit consent of the User in order to share the data with an Information Provider or another service such as a Token Issuer. Some Information Providers handle the access rights management (checking rights, allow the user to manage these rights, ...) . To issue a claim, a Claim Issuer usually has to ask information about the user. It can ask the user for these information. But a user doesn't want to send the same data and fill the same forms each time he wants a claim. Therefore, they may use an Information Provider to keep their information in a single place. Other services may then request these data from the Information Provider, with the explicit consent of the user. Most SDK provides all methods required to request and access these information.","title":"Introduction to Claim Issuers"},{"location":"developers/providers/Claim Issuers/presentation/#summary","text":"Whatever types of claims the service will issue, it must implement the following features: Ability to publish claim on the BlockChain. Manage a Claim Registry on the BlockChain (optional). Manage access grants to data of a claim.","title":"Summary"},{"location":"developers/providers/Claim Issuers/specification/","text":"","title":"Specification"},{"location":"developers/providers/Information Providers/get-started/","text":"","title":"Get started"},{"location":"developers/providers/Information Providers/presentation/","text":"Introduction to Information Providers An Information Provider is a service that stores pieces of information about an identity without publishing them to the BlockChain, by opposition to Claims that are stored on-chain. The identity is identified by its unique smart contract address. The owner of the identity should always should be able to access and manage its data as long as he/she is able to sign messages with a MANAGEMENT of the Identity. An Information Provider must provide the following features: Store information about an Identity. Manage access grants to these information.","title":"What are they?"},{"location":"developers/providers/Information Providers/presentation/#introduction-to-information-providers","text":"An Information Provider is a service that stores pieces of information about an identity without publishing them to the BlockChain, by opposition to Claims that are stored on-chain. The identity is identified by its unique smart contract address. The owner of the identity should always should be able to access and manage its data as long as he/she is able to sign messages with a MANAGEMENT of the Identity. An Information Provider must provide the following features: Store information about an Identity. Manage access grants to these information.","title":"Introduction to Information Providers"},{"location":"developers/providers/Information Providers/specification/","text":"Specification for Information Providers An Information Provider MUST expose the following endpoints: Route Description Authentication Returns GET _/identities/{identityID}/information?types=typeA&types=typeB Get information whose types are specified in the types query parameter. JWT token in Authorization: Bearer <token> header Array of information. POST _/identities/{identityID}/information/access_requests Request access whose types are specified in the information_types body parameter. JWT token in Authorization: Bearer <token> header The access request challenge (with random string inside). POST _/access-grants/{accessGrantId}/validation Validate an access grant create when making an access_request with a signature in body. None The validation response (and access token for IMMEDIATE access). Request access to information Information are identified by their type . An identity can only have one information per type and per provider.","title":"Specification"},{"location":"developers/providers/Information Providers/specification/#specification-for-information-providers","text":"An Information Provider MUST expose the following endpoints: Route Description Authentication Returns GET _/identities/{identityID}/information?types=typeA&types=typeB Get information whose types are specified in the types query parameter. JWT token in Authorization: Bearer <token> header Array of information. POST _/identities/{identityID}/information/access_requests Request access whose types are specified in the information_types body parameter. JWT token in Authorization: Bearer <token> header The access request challenge (with random string inside). POST _/access-grants/{accessGrantId}/validation Validate an access grant create when making an access_request with a signature in body. None The validation response (and access token for IMMEDIATE access).","title":"Specification for Information Providers"},{"location":"developers/providers/Information Providers/specification/#request-access-to-information","text":"Information are identified by their type . An identity can only have one information per type and per provider.","title":"Request access to information"},{"location":"developers/sdks/identity-sdk/blockchain-providers/","text":"BlockChain Provider It is recommended that you connect with a BlockChain Provider to retrieve information directly from the BlockChaim. If you don't intend to validate data with the BlockChain but to only use an Identity Provider, you can pass this step. The SDK is using Ethers to connect with Ethereum network. Thus, any provider supported by Ethers can be used with the SDK. This means any standard web3 provider should by supported. Connect to a default provider // You can use any standard network name // - \"homestead\" // - \"rinkeby\" // - \"ropsten\" // - \"kovan\" let provider = ethers . getDefaultProvider ( 'ropsten' ); let provider = ethers . getDefaultProvider ( 'homestead' ); Connect to JSON RPC // When using the JSON-RPC API, the network will be automatically detected // Default: http://localhost:8545 let httpProvider = new ethers . providers . JsonRpcProvider (); Connect to any Web3 Provider // When using a Web3 provider, the network will be automatically detected // e.g. HTTP provider let currentProvider = new web3 . providers . HttpProvider ( 'http://localhost:8545' ); let web3Provider = new ethers . providers . Web3Provider ( currentProvider ); Connect to MetaMask (for in-browser usage) // The network will be automatically detected; if the network is // changed in MetaMask, it causes a page refresh. let provider = new ethers . providers . Web3Provider ( web3 . currentProvider ); Please refer to the Ethers Providers Documentation for more information.","title":"BlockChain Providers"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#blockchain-provider","text":"It is recommended that you connect with a BlockChain Provider to retrieve information directly from the BlockChaim. If you don't intend to validate data with the BlockChain but to only use an Identity Provider, you can pass this step. The SDK is using Ethers to connect with Ethereum network. Thus, any provider supported by Ethers can be used with the SDK. This means any standard web3 provider should by supported.","title":"BlockChain Provider"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-a-default-provider","text":"// You can use any standard network name // - \"homestead\" // - \"rinkeby\" // - \"ropsten\" // - \"kovan\" let provider = ethers . getDefaultProvider ( 'ropsten' ); let provider = ethers . getDefaultProvider ( 'homestead' );","title":"Connect to a default provider"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-json-rpc","text":"// When using the JSON-RPC API, the network will be automatically detected // Default: http://localhost:8545 let httpProvider = new ethers . providers . JsonRpcProvider ();","title":"Connect to JSON RPC"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-any-web3-provider","text":"// When using a Web3 provider, the network will be automatically detected // e.g. HTTP provider let currentProvider = new web3 . providers . HttpProvider ( 'http://localhost:8545' ); let web3Provider = new ethers . providers . Web3Provider ( currentProvider );","title":"Connect to any Web3 Provider"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-metamask-for-in-browser-usage","text":"// The network will be automatically detected; if the network is // changed in MetaMask, it causes a page refresh. let provider = new ethers . providers . Web3Provider ( web3 . currentProvider ); Please refer to the Ethers Providers Documentation for more information.","title":"Connect to MetaMask (for in-browser usage)"},{"location":"developers/sdks/identity-sdk/configuration/","text":"Configuration Identity Providers By default, unsecured Identity Providers are not allowed. The SDK will refuse to fetch data on these endpoints. A claim that has an uri which is not an HTTPS endpoint won't be retrieved. Allow unsecured endpoints with: const IdentitySDK = require ( '@investorid/identity-sdk' ); IdentitySDK . config ({ allowUnsecuredProviders : true });","title":"Configuration"},{"location":"developers/sdks/identity-sdk/configuration/#configuration","text":"","title":"Configuration"},{"location":"developers/sdks/identity-sdk/configuration/#identity-providers","text":"By default, unsecured Identity Providers are not allowed. The SDK will refuse to fetch data on these endpoints. A claim that has an uri which is not an HTTPS endpoint won't be retrieved. Allow unsecured endpoints with: const IdentitySDK = require ( '@investorid/identity-sdk' ); IdentitySDK . config ({ allowUnsecuredProviders : true });","title":"Identity Providers"},{"location":"developers/sdks/identity-sdk/examples/","text":"Some example of usage Execute direct contract calls You can also call function from the smart contract using the Identity.instance property. const IdentitySDK = require ( '@investorid/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const claims = await identity . instance . getClaimIdsByType ( 1 ); console . log ( claims ); // Will return the unparsed response from the blockchain. }); All functions from the ERC734 and ERC735 standards will be callable, as well as all custom functions implemented in the T-REX standard . Get keys of an Identity const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const keys = await identity . getKeysByPurpose ( IdentitySDK . utils . enums . KeyPurpose . CLAIM ); console . log ( keys ); console . log ( await identity . getKeyPurpose ( keys [ 0 ]. key )); })(); Deploy an identity const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const PRIVATE_KEY = 'tokeny_private_key' ; const wallet = new Ethers . Wallet ( PRIVATE_KEY , provider ); ( async () => { // Deploy a new Identity, will await transaction confirmation. const identity = await IdentitySDK . Identity . deployNew ( wallet ); })(); Get details of a claim with an Claim Issuer const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); ( async () => { IdentitySDK . config ({ allowUnsecuredProviders : true }); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); const claims = await identity . getClaimsByType ( IdentitySDK . utils . enums . ClaimType . KYC ); const claim = new IdentitySDK . Claim ( claims [ 0 ]); await claim . populate (); // Will fetch public data of the claim from the claim URI. console . log ( claim ); /* Claim { data: '0x65773261724950755a302f626e5a744e327961676676376139462f6a3672744a4e3761666a52414c6871493d', id: '0x3c6532cc1f4d1a44de8f58d4bde617bef8e744168bf92d783a0e1b66e7c6a44a', issuer: '0x8c78fF753c63ea0e8CA1FcA9997A132bC3e6a8F1', scheme: 1, type: 1, uri: 'http://localhost:8080/claims/b701e350-2a08-11e9-ac7e-517ddf10b60e', issuanceDate: 2019-02-06T12:14:12.996Z, emissionDate: 2019-02-06T12:15:02.039Z, status: 'PENDING', publicData: { result: 'clear' } } */ })();","title":"Examples"},{"location":"developers/sdks/identity-sdk/examples/#some-example-of-usage","text":"","title":"Some example of usage"},{"location":"developers/sdks/identity-sdk/examples/#execute-direct-contract-calls","text":"You can also call function from the smart contract using the Identity.instance property. const IdentitySDK = require ( '@investorid/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const claims = await identity . instance . getClaimIdsByType ( 1 ); console . log ( claims ); // Will return the unparsed response from the blockchain. }); All functions from the ERC734 and ERC735 standards will be callable, as well as all custom functions implemented in the T-REX standard .","title":"Execute direct contract calls"},{"location":"developers/sdks/identity-sdk/examples/#get-keys-of-an-identity","text":"const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const keys = await identity . getKeysByPurpose ( IdentitySDK . utils . enums . KeyPurpose . CLAIM ); console . log ( keys ); console . log ( await identity . getKeyPurpose ( keys [ 0 ]. key )); })();","title":"Get keys of an Identity"},{"location":"developers/sdks/identity-sdk/examples/#deploy-an-identity","text":"const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const PRIVATE_KEY = 'tokeny_private_key' ; const wallet = new Ethers . Wallet ( PRIVATE_KEY , provider ); ( async () => { // Deploy a new Identity, will await transaction confirmation. const identity = await IdentitySDK . Identity . deployNew ( wallet ); })();","title":"Deploy an identity"},{"location":"developers/sdks/identity-sdk/examples/#get-details-of-a-claim-with-an-claim-issuer","text":"const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); ( async () => { IdentitySDK . config ({ allowUnsecuredProviders : true }); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); const claims = await identity . getClaimsByType ( IdentitySDK . utils . enums . ClaimType . KYC ); const claim = new IdentitySDK . Claim ( claims [ 0 ]); await claim . populate (); // Will fetch public data of the claim from the claim URI. console . log ( claim ); /* Claim { data: '0x65773261724950755a302f626e5a744e327961676676376139462f6a3672744a4e3761666a52414c6871493d', id: '0x3c6532cc1f4d1a44de8f58d4bde617bef8e744168bf92d783a0e1b66e7c6a44a', issuer: '0x8c78fF753c63ea0e8CA1FcA9997A132bC3e6a8F1', scheme: 1, type: 1, uri: 'http://localhost:8080/claims/b701e350-2a08-11e9-ac7e-517ddf10b60e', issuanceDate: 2019-02-06T12:14:12.996Z, emissionDate: 2019-02-06T12:15:02.039Z, status: 'PENDING', publicData: { result: 'clear' } } */ })();","title":"Get details of a claim with an Claim Issuer"},{"location":"developers/sdks/identity-sdk/get-started/","text":"Get Started Installation Install with npm install @investorid/identity-sdk Then require with: const IdentitySDK = require ( '@investorid/identity-sdk' ); Load an Identity The unique identifier of an Identity is its address. To load its data from the BlockChain, you need to instantiate a connection with a BlockChain provider. In this documentation, the test network ropsten will be used. Replace by homestead to target main network (see the BlockChain Providers for more information on different type of network). const ethers = require ( 'ethers' ); const provider = ethers . getDefaultProvider ( 'ropsten' ); // instantiate an Identity from its address on a specific network. const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); Use SDK methods to retrieve data Once the identity is loaded from an address, you can call the methods from the Identity object. Here is a basic one that retrieves all claims of an identity by type. ( async () => { const claims = await identity . getClaimsByType ( 1 ); console . log ( claims ); // Will return the parsed claims of the identity. })();","title":"Get Started"},{"location":"developers/sdks/identity-sdk/get-started/#get-started","text":"","title":"Get Started"},{"location":"developers/sdks/identity-sdk/get-started/#installation","text":"Install with npm install @investorid/identity-sdk Then require with: const IdentitySDK = require ( '@investorid/identity-sdk' );","title":"Installation"},{"location":"developers/sdks/identity-sdk/get-started/#load-an-identity","text":"The unique identifier of an Identity is its address. To load its data from the BlockChain, you need to instantiate a connection with a BlockChain provider. In this documentation, the test network ropsten will be used. Replace by homestead to target main network (see the BlockChain Providers for more information on different type of network). const ethers = require ( 'ethers' ); const provider = ethers . getDefaultProvider ( 'ropsten' ); // instantiate an Identity from its address on a specific network. const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider );","title":"Load an Identity"},{"location":"developers/sdks/identity-sdk/get-started/#use-sdk-methods-to-retrieve-data","text":"Once the identity is loaded from an address, you can call the methods from the Identity object. Here is a basic one that retrieves all claims of an identity by type. ( async () => { const claims = await identity . getClaimsByType ( 1 ); console . log ( claims ); // Will return the parsed claims of the identity. })();","title":"Use SDK methods to retrieve data"},{"location":"developers/sdks/identity-sdk/identity-sdk/","text":"The Identity SDK This package facilitates the interaction with Identities stored in the BlockChain. Forewords It is recommended you read the Identities section before continuing further. The JS Identity SDK targets server-side environments with a NodeJS Runtime. It is intended to work in-browser with web3 provider as well, but it was not built for browsers yet. It is intended to support any identity compliant with the ERC734 and ERC735 standards (which are still in draft state). It will work especially well with the contract implementations of the T-REX standard . Functionality Deploy identities List keys on an Identity. Manage keys on an Identity (if allowed). List Claims on an Identity. Manage Claims on an Identity (if allowed). Issue claims for an Identity (if allowed). Verify a claim (check validity). Fetch claim data using their URI. Request access to claim private data using their URI. Use access grants to access private data of claims.","title":"Home"},{"location":"developers/sdks/identity-sdk/identity-sdk/#the-identity-sdk","text":"This package facilitates the interaction with Identities stored in the BlockChain.","title":"The Identity SDK"},{"location":"developers/sdks/identity-sdk/identity-sdk/#forewords","text":"It is recommended you read the Identities section before continuing further. The JS Identity SDK targets server-side environments with a NodeJS Runtime. It is intended to work in-browser with web3 provider as well, but it was not built for browsers yet. It is intended to support any identity compliant with the ERC734 and ERC735 standards (which are still in draft state). It will work especially well with the contract implementations of the T-REX standard .","title":"Forewords"},{"location":"developers/sdks/identity-sdk/identity-sdk/#functionality","text":"Deploy identities List keys on an Identity. Manage keys on an Identity (if allowed). List Claims on an Identity. Manage Claims on an Identity (if allowed). Issue claims for an Identity (if allowed). Verify a claim (check validity). Fetch claim data using their URI. Request access to claim private data using their URI. Use access grants to access private data of claims.","title":"Functionality"},{"location":"developers/sdks/identity-sdk/signer-module/","text":"SignerModule Many interaction with identities, and especially accessing claims, require to sign a challenge message. Functions requiring these signatures expect a SignerModule as argument. A SignerModule must expose a .getPublicKey() and a .signMessage(message: string) functions. This, for instance, id a valid simple SignerModule: const jsrasign = require ( 'jsrasign' ); const signer = { getPublicKey : async () => ({ key : \"-----BEGIN CERTIFICATE----- my_super_public_key -----END CERTIFICATE-----\" , type : \"X.509\" , signingMethod : \"SHA-256\" , }), signMessage : async ( message ) => { const signer = new jsrsasign . Signature ({ alg : 'SHA256withRSA' }); signer . init ( \"-----BEGIN CERTIFICATE----- my_super_PRIVATE_no_really_super_secret_PRIVATE_key -----END CERTIFICATE-----\" ); signer . updateString ( message ); return signer . sign (); }, }; It can be used in functions such as Claim.requestAccess(): claim . requestAccess ( IdentitySDK . utils . enums . AccessGrantType . PERSISTENT , signer );","title":"Signing Challenges"},{"location":"developers/sdks/identity-sdk/signer-module/#signermodule","text":"Many interaction with identities, and especially accessing claims, require to sign a challenge message. Functions requiring these signatures expect a SignerModule as argument. A SignerModule must expose a .getPublicKey() and a .signMessage(message: string) functions. This, for instance, id a valid simple SignerModule: const jsrasign = require ( 'jsrasign' ); const signer = { getPublicKey : async () => ({ key : \"-----BEGIN CERTIFICATE----- my_super_public_key -----END CERTIFICATE-----\" , type : \"X.509\" , signingMethod : \"SHA-256\" , }), signMessage : async ( message ) => { const signer = new jsrsasign . Signature ({ alg : 'SHA256withRSA' }); signer . init ( \"-----BEGIN CERTIFICATE----- my_super_PRIVATE_no_really_super_secret_PRIVATE_key -----END CERTIFICATE-----\" ); signer . updateString ( message ); return signer . sign (); }, }; It can be used in functions such as Claim.requestAccess(): claim . requestAccess ( IdentitySDK . utils . enums . AccessGrantType . PERSISTENT , signer );","title":"SignerModule"},{"location":"identities/claims/","text":"Identity Claims Claims can be obtained from several sources: Identity Owner (so-called \"self-attested\" claims), Claim Issuers, or technically anyone the Identity Owner allowed to add claims to its identity (CLAIM key or above). They are stored in a ClaimHolder contract (ERC735) that is owned by an Identity (ERC734) contract. Issued claims can be removed from a ClaimHolder by: the Identity Owner (has the ability to remove ANY claim), the issuer of the claim to be removed, or technically anyone the Identity Owner allowed to manage claims on its identity (CLAIM key or above). Note that there are NO WAY to verify that the identity is strictly compliant with the standard. A claim signer may only issue one claim per type per Identity. It will be stored by a unique identifier composed with the issuer address and the claim type. Issuing a new claim for the same type will override the first instance. As T-REX intends to support any ERC725/725 compliant Identity, a claim issuer has NO CERTAINTY that the claim will be added or updated, as the Identity contract implementation could deny the update. The only security is that NO ONE can fake the claim issuer signing key, thus a valid claim can only be issued by an approved claim issuer. Claims may be related to sensitive data. To respect legislation, these data cannot be publicly stored on the blockchain. Storing encrypted data in the blockchain is not recommended aswell. Claim issuer should store the data they checked in an secured off-chain database, and refer these data in the added claim. To ensure compliance, a hash of these data should also be stored with the claim added to the Identity. As external data is not accessible from within the blockchain when transactions occurs, the claim should be self-explanatory to validate compliance for the given token, without exposing sensitive data. When the claim is related to a data that is part of an exhaustive list of possibilities, i.e. sex, country of residence, age, ... the hash is not enough to keep the data private cause it is pretty easy to find the private data by iterating on a limited list of possibilities, therefore, in this type of case we should hash a concatenation of this data with another data that is not part of an exhaustive list, e.g. the name or the first name of the user. Some claims are therefore sharable between tokens of multiple issuers (for instance: accreditation status) and are called Generic Claims , or between token for a same issuer (for instance, the fact that the investor is approved for token investment for a set of tokens) and are called Specific Claims . Specific claims can be customized per token or issuer (for instance, the issuer asks for a claim check that will allow him to know that the investor satisfies a set of criteria like country, occupation, in a list of approved ones that he configured with the claim issuer). Generic claims are public statuses, that usually have an expiration date. To generate a claim, a Claim Issuer can ask the Identity Owner all data it requires through a custom User Interface, mail exchanges, research... Some claim issuer allows user to share their information with other claim issuers approved that implements an OAuth client. The list and content of data shared are explicitly displayed to the user when an access is requested by an application. A claim can be requested by anyone for an Identity.","title":"Claims"},{"location":"identities/claims/#identity-claims","text":"Claims can be obtained from several sources: Identity Owner (so-called \"self-attested\" claims), Claim Issuers, or technically anyone the Identity Owner allowed to add claims to its identity (CLAIM key or above). They are stored in a ClaimHolder contract (ERC735) that is owned by an Identity (ERC734) contract. Issued claims can be removed from a ClaimHolder by: the Identity Owner (has the ability to remove ANY claim), the issuer of the claim to be removed, or technically anyone the Identity Owner allowed to manage claims on its identity (CLAIM key or above). Note that there are NO WAY to verify that the identity is strictly compliant with the standard. A claim signer may only issue one claim per type per Identity. It will be stored by a unique identifier composed with the issuer address and the claim type. Issuing a new claim for the same type will override the first instance. As T-REX intends to support any ERC725/725 compliant Identity, a claim issuer has NO CERTAINTY that the claim will be added or updated, as the Identity contract implementation could deny the update. The only security is that NO ONE can fake the claim issuer signing key, thus a valid claim can only be issued by an approved claim issuer. Claims may be related to sensitive data. To respect legislation, these data cannot be publicly stored on the blockchain. Storing encrypted data in the blockchain is not recommended aswell. Claim issuer should store the data they checked in an secured off-chain database, and refer these data in the added claim. To ensure compliance, a hash of these data should also be stored with the claim added to the Identity. As external data is not accessible from within the blockchain when transactions occurs, the claim should be self-explanatory to validate compliance for the given token, without exposing sensitive data. When the claim is related to a data that is part of an exhaustive list of possibilities, i.e. sex, country of residence, age, ... the hash is not enough to keep the data private cause it is pretty easy to find the private data by iterating on a limited list of possibilities, therefore, in this type of case we should hash a concatenation of this data with another data that is not part of an exhaustive list, e.g. the name or the first name of the user. Some claims are therefore sharable between tokens of multiple issuers (for instance: accreditation status) and are called Generic Claims , or between token for a same issuer (for instance, the fact that the investor is approved for token investment for a set of tokens) and are called Specific Claims . Specific claims can be customized per token or issuer (for instance, the issuer asks for a claim check that will allow him to know that the investor satisfies a set of criteria like country, occupation, in a list of approved ones that he configured with the claim issuer). Generic claims are public statuses, that usually have an expiration date. To generate a claim, a Claim Issuer can ask the Identity Owner all data it requires through a custom User Interface, mail exchanges, research... Some claim issuer allows user to share their information with other claim issuers approved that implements an OAuth client. The list and content of data shared are explicitly displayed to the user when an access is requested by an application. A claim can be requested by anyone for an Identity.","title":"Identity Claims"},{"location":"identities/connect-with-identity/","text":"Connect with investorID An InvestorID allows to login to a website using your Identity as it is possible with Social Providers. When an user attempt to login, the server generates a challenge to be signed using a wallet linked to the Identity. The server has the possibility to request access to some Information and Claims about the Identity. The following process explains the authentication flow for Connect with Identity . To summarize, a website requests access to certain set of information, and allows the connection once it has all the access it requires. The website (or service provider) will be able to request more access, but these will required each time a new signature from the Identity Owner. An Identity Owner using its Identity to connect to a service will be able to share, on the request of the service, some of the data related to the Identity. The list will be signed by the Identity Owner and the service will not have access to more data. This may include: First and Last Name Email Phone number (if available) Address Any claim data stored by the Tokeny Identity Service. Once the Identity is connected, the Identity Owner will be able to share additional data such as: Other claim data or information stored by other Information Providers or Claim issuers. There are multiple ways to required access to information: immediate grant , which only allow access once to information, and persistent grants , which allows longer-term access until the grant is revoked by the Identity Owner. Refer to the Sharing data section for more information about access grants. graph TD A(Arrival on SignIn) -->|clicks on 'Connect with InvestorID'| B B(Load Identity) B --> C{Attempt to detect provider} C -->|Detected| D(Ask for confirmation) C -->|Not detected| E(Display provider selection) D --> |confirms provider|F E --> |selects provider|F F(Display terms & conditions + requested information/claims) F --> |Approves T&C|G G(Request information access to provider) G --> H H{Identity found by provider} H --> |NO|I(Display Identity Not Found Error) H --> |YES + challenge|J J(Display challenge to be signed) J --> |User signs challenge|K K(Validate access request with provider by sending signature) K --> |Provider rejects the signed challenge|L(display error message) K --> |Provider validates signed challenge|M M(Use access grants to obtain an access token) M --> N(Use generated access token to retrieve information) N --> O(User logged in, and server has access to required information data)","title":"Connect with Identity"},{"location":"identities/connect-with-identity/#connect-with-investorid","text":"An InvestorID allows to login to a website using your Identity as it is possible with Social Providers. When an user attempt to login, the server generates a challenge to be signed using a wallet linked to the Identity. The server has the possibility to request access to some Information and Claims about the Identity. The following process explains the authentication flow for Connect with Identity . To summarize, a website requests access to certain set of information, and allows the connection once it has all the access it requires. The website (or service provider) will be able to request more access, but these will required each time a new signature from the Identity Owner. An Identity Owner using its Identity to connect to a service will be able to share, on the request of the service, some of the data related to the Identity. The list will be signed by the Identity Owner and the service will not have access to more data. This may include: First and Last Name Email Phone number (if available) Address Any claim data stored by the Tokeny Identity Service. Once the Identity is connected, the Identity Owner will be able to share additional data such as: Other claim data or information stored by other Information Providers or Claim issuers. There are multiple ways to required access to information: immediate grant , which only allow access once to information, and persistent grants , which allows longer-term access until the grant is revoked by the Identity Owner. Refer to the Sharing data section for more information about access grants. graph TD A(Arrival on SignIn) -->|clicks on 'Connect with InvestorID'| B B(Load Identity) B --> C{Attempt to detect provider} C -->|Detected| D(Ask for confirmation) C -->|Not detected| E(Display provider selection) D --> |confirms provider|F E --> |selects provider|F F(Display terms & conditions + requested information/claims) F --> |Approves T&C|G G(Request information access to provider) G --> H H{Identity found by provider} H --> |NO|I(Display Identity Not Found Error) H --> |YES + challenge|J J(Display challenge to be signed) J --> |User signs challenge|K K(Validate access request with provider by sending signature) K --> |Provider rejects the signed challenge|L(display error message) K --> |Provider validates signed challenge|M M(Use access grants to obtain an access token) M --> N(Use generated access token to retrieve information) N --> O(User logged in, and server has access to required information data)","title":"Connect with investorID"},{"location":"identities/grants/","text":"Sharing Identity data Concept InvestorID gives the Identity Owner the control of his/her Identity. When an Identity Owner decides to share information about the Identity with a third-party service, an explicit signature of an access challenge is requested. This allows Information Consumers to request access to Identity Data such as: Basic Information data (first name, last name, email, phone, address). Claim data (access to a precise claim content) By signing an access challenge, the Identity Owner creates an Access Grant for a service, that can be revoked if needed. Note that a revocation will not delete the data eventually stored by the service, but will prevent it from access again to the data that can be updated. The following sequence diagram illustrates the access grant flow: sequenceDiagram participant IO as Identity Owner participant W as Website participant TIS as Identity Service IO ->> W: request login activate W W ->> -TIS: request challenge with fields activate TIS TIS ->> -W: Access Grant Request with challenge activate W W ->> -IO: challenge activate IO IO ->> IO: Sign with wallet IO ->> -TIS: signed challenge activate TIS TIS ->> TIS: Verify signature, validate grant TIS ->> -W: Access Grant completed (with refresh token) opt Access data W ->> TIS: request access token activate TIS TIS ->> TIS: check access grant validity TIS ->> -W: access token activate W W ->> -TIS: request data activate TIS TIS ->> TIS: check access token rights TIS ->> -W: data end Types of Access grants There are two types of access grants flow: Synchronous immediate grant The user will sign a challenge that the service will use immediately to access the data. The access grant can be used only once. The grant will remain stored as a proof. Asynchronous persistent grant A service requests access to the data. The Identity Owner will be notified and will be able to later approve the request. The access grant can be used until it is revoked. An Access Grant can be requested with a POST from the URI of the resource to be shared, with /access-requests appended. For instance, if a claim has to be shared, and its URI is GET http://api.identity-service.example.com/claims/09724-IiuD73-989bjD8 , the access grant request url will be POST http://api.identity-service.example.com/claims/09724-IiuD73-989bjD8/access-requests . The response Location will point toward the URI of the Access Grant request, that can be itself validated by appending POST /validations . In the above example, to validate the access grant request, call POST http://api.identity-service.example.com/access-grants/8hy67-hu79k-gf76hk/validations . Information Providers should support at least one of the following authentication methods for Service Providers: API Keys. Challenge Signature flow. Synchronous Immediate grant sequenceDiagram participant I as Identity Owner participant S as Consumer Service participant CI as Identity Service activate S S->>+CI: Request explicit grant deactivate S CI-->>-S: challenge string activate S S->>+I: challenge string deactivate S I->>I: Sign challenge I-->>-S: signed challenge activate S S->>+CI: signed challenge deactivate S CI->>CI: Validate challenge CI-->>-S: access token activate S S->>+CI: request data with access token deactivate S CI->>CI: Validate access token CI-->>-S: claim private data Asynchronous Persistent Grant sequenceDiagram participant I as Identity Owner participant S as Consumer Service participant IP as Information Provider activate S S->>+IP: Request access deactivate S IP-->>S: confirmation IP->>-I: notify of access request I->>+IP: grant access IP->>IP: Update access rights of Your Service IP-->>I: confirmation IP->>-S: grant notification S->>+IP: Request claim data (with API KEY or challenge signature) IP->>IP: Check API KEY/challenge access rights IP-->>-S: Claim private data The confirmation response from the Identity Service returns to the requester service the challenge to be signed. This means that the service can request the Identity Owner signature without having to wait for the notification to be sent to the user. Revoking and monitoring Access Grants Each Information Provider offers different level of access grants control. Some might accept only immediate grants. Some will allow Identity Owners to see which access grants they emitted, both immediate and persistent, and how they are currently used. When an Identity Owner revokes an Access Grants, the related service should no longer be able to access the data.","title":"Sharing data"},{"location":"identities/grants/#sharing-identity-data","text":"","title":"Sharing Identity data"},{"location":"identities/grants/#concept","text":"InvestorID gives the Identity Owner the control of his/her Identity. When an Identity Owner decides to share information about the Identity with a third-party service, an explicit signature of an access challenge is requested. This allows Information Consumers to request access to Identity Data such as: Basic Information data (first name, last name, email, phone, address). Claim data (access to a precise claim content) By signing an access challenge, the Identity Owner creates an Access Grant for a service, that can be revoked if needed. Note that a revocation will not delete the data eventually stored by the service, but will prevent it from access again to the data that can be updated. The following sequence diagram illustrates the access grant flow: sequenceDiagram participant IO as Identity Owner participant W as Website participant TIS as Identity Service IO ->> W: request login activate W W ->> -TIS: request challenge with fields activate TIS TIS ->> -W: Access Grant Request with challenge activate W W ->> -IO: challenge activate IO IO ->> IO: Sign with wallet IO ->> -TIS: signed challenge activate TIS TIS ->> TIS: Verify signature, validate grant TIS ->> -W: Access Grant completed (with refresh token) opt Access data W ->> TIS: request access token activate TIS TIS ->> TIS: check access grant validity TIS ->> -W: access token activate W W ->> -TIS: request data activate TIS TIS ->> TIS: check access token rights TIS ->> -W: data end","title":"Concept"},{"location":"identities/grants/#types-of-access-grants","text":"There are two types of access grants flow: Synchronous immediate grant The user will sign a challenge that the service will use immediately to access the data. The access grant can be used only once. The grant will remain stored as a proof. Asynchronous persistent grant A service requests access to the data. The Identity Owner will be notified and will be able to later approve the request. The access grant can be used until it is revoked. An Access Grant can be requested with a POST from the URI of the resource to be shared, with /access-requests appended. For instance, if a claim has to be shared, and its URI is GET http://api.identity-service.example.com/claims/09724-IiuD73-989bjD8 , the access grant request url will be POST http://api.identity-service.example.com/claims/09724-IiuD73-989bjD8/access-requests . The response Location will point toward the URI of the Access Grant request, that can be itself validated by appending POST /validations . In the above example, to validate the access grant request, call POST http://api.identity-service.example.com/access-grants/8hy67-hu79k-gf76hk/validations . Information Providers should support at least one of the following authentication methods for Service Providers: API Keys. Challenge Signature flow.","title":"Types of Access grants"},{"location":"identities/grants/#synchronous-immediate-grant","text":"sequenceDiagram participant I as Identity Owner participant S as Consumer Service participant CI as Identity Service activate S S->>+CI: Request explicit grant deactivate S CI-->>-S: challenge string activate S S->>+I: challenge string deactivate S I->>I: Sign challenge I-->>-S: signed challenge activate S S->>+CI: signed challenge deactivate S CI->>CI: Validate challenge CI-->>-S: access token activate S S->>+CI: request data with access token deactivate S CI->>CI: Validate access token CI-->>-S: claim private data","title":"Synchronous Immediate grant"},{"location":"identities/grants/#asynchronous-persistent-grant","text":"sequenceDiagram participant I as Identity Owner participant S as Consumer Service participant IP as Information Provider activate S S->>+IP: Request access deactivate S IP-->>S: confirmation IP->>-I: notify of access request I->>+IP: grant access IP->>IP: Update access rights of Your Service IP-->>I: confirmation IP->>-S: grant notification S->>+IP: Request claim data (with API KEY or challenge signature) IP->>IP: Check API KEY/challenge access rights IP-->>-S: Claim private data The confirmation response from the Identity Service returns to the requester service the challenge to be signed. This means that the service can request the Identity Owner signature without having to wait for the notification to be sent to the user.","title":"Asynchronous Persistent Grant"},{"location":"identities/grants/#revoking-and-monitoring-access-grants","text":"Each Information Provider offers different level of access grants control. Some might accept only immediate grants. Some will allow Identity Owners to see which access grants they emitted, both immediate and persistent, and how they are currently used. When an Identity Owner revokes an Access Grants, the related service should no longer be able to access the data.","title":"Revoking and monitoring Access Grants"},{"location":"identities/information/","text":"Basic Information of Identities An InvestorID Identity has a unique identifier: its address. Many services can store information about an Identity, while keeping these information outside the blockchain. For instance, the service that deployed the Identity will probably store name, email address, postal address, country, website, and maybe others piece of data about the identity. A service that stores and diffuse information about an Identity is called an Information Provider . Any Service Provider is able to request these information from the Information Provider . t will respond the data only if the Service Provider is allowed to access the information. The Identity Owner has a complete control over what information are shared with which services. Some Information Provider will notify the Identity Owner when an access request is emitted, some will not. Accessing an information follow the same rules as accessing claims. Refer to the Sharing Data section. A list of standard information types can be found in the Developer Section .","title":"Basic Information"},{"location":"identities/information/#basic-information-of-identities","text":"An InvestorID Identity has a unique identifier: its address. Many services can store information about an Identity, while keeping these information outside the blockchain. For instance, the service that deployed the Identity will probably store name, email address, postal address, country, website, and maybe others piece of data about the identity. A service that stores and diffuse information about an Identity is called an Information Provider . Any Service Provider is able to request these information from the Information Provider . t will respond the data only if the Service Provider is allowed to access the information. The Identity Owner has a complete control over what information are shared with which services. Some Information Provider will notify the Identity Owner when an access request is emitted, some will not. Accessing an information follow the same rules as accessing claims. Refer to the Sharing Data section. A list of standard information types can be found in the Developer Section .","title":"Basic Information of Identities"},{"location":"identities/introduction/","text":"InvestorID Identities InvestorID Identities are stored on the BlockChain, in a decentralized way. They can't be hidden nor deleted. No service or organization can remove your access rights to it, and it spans a lifetime. Anyone can issue its own Identity, it only takes a bit of knowledge, time, and less than a few cents. Identities are Smart Contract, deployed on the Ethereum Main Network. Any implementation standard to the ERC734 and ERC725 proposals are supported by the InvestorID standard, and thus with any service that supports the InvestorID standard. Yet, an Identity has no value itself. This is the information attached to it that makes an Identity what it is: an Identity. These information can be self-attested, and many website will only use self-attested information such as an username. Regulated exchanges, however, requires an Identity to be \"real\" one, linked to an existing person or organization. Proof of these information are called Claims . They are issued by any Claim Issuer that is allowed by the Identity Owner to publish claims about the Identity. For example, a Claim Issuer could emit a claim saying that a given Identity has passed an Identity Check with an ID card and a selfie. Of course, sensitive information such as the ID card number or the picture itself are not stored on the blockchain publicly. The Claim Issuer will store the claim Private Data on its off-chain servers, and will publish publicly on-chain a signature. Therefore, anyone know that the identity has passed an Identity Check. But to access the data, one would need the explicit consent of the Identity Owner allowing the consultation of the private data. What can I do with an InvestorID? Log in to compatible websites without any password, using an hardware security key. Participate in regulated tokenized assets offerings, and exchange tokens in a decentralized way.","title":"What is an Identity"},{"location":"identities/introduction/#investorid-identities","text":"InvestorID Identities are stored on the BlockChain, in a decentralized way. They can't be hidden nor deleted. No service or organization can remove your access rights to it, and it spans a lifetime. Anyone can issue its own Identity, it only takes a bit of knowledge, time, and less than a few cents. Identities are Smart Contract, deployed on the Ethereum Main Network. Any implementation standard to the ERC734 and ERC725 proposals are supported by the InvestorID standard, and thus with any service that supports the InvestorID standard. Yet, an Identity has no value itself. This is the information attached to it that makes an Identity what it is: an Identity. These information can be self-attested, and many website will only use self-attested information such as an username. Regulated exchanges, however, requires an Identity to be \"real\" one, linked to an existing person or organization. Proof of these information are called Claims . They are issued by any Claim Issuer that is allowed by the Identity Owner to publish claims about the Identity. For example, a Claim Issuer could emit a claim saying that a given Identity has passed an Identity Check with an ID card and a selfie. Of course, sensitive information such as the ID card number or the picture itself are not stored on the blockchain publicly. The Claim Issuer will store the claim Private Data on its off-chain servers, and will publish publicly on-chain a signature. Therefore, anyone know that the identity has passed an Identity Check. But to access the data, one would need the explicit consent of the Identity Owner allowing the consultation of the private data.","title":"InvestorID Identities"},{"location":"identities/introduction/#what-can-i-do-with-an-investorid","text":"Log in to compatible websites without any password, using an hardware security key. Participate in regulated tokenized assets offerings, and exchange tokens in a decentralized way.","title":"What can I do with an InvestorID?"}]}