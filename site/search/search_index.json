{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the official documentation for the InvestorID organization . Learn more about InvestorID on the official website .","title":"Home"},{"location":"#home","text":"Welcome to the official documentation for the InvestorID organization . Learn more about InvestorID on the official website .","title":"Home"},{"location":"introduction/","text":"Identity ecosystem for digital assets holders What is InvestorID? InvestorID identities are smart contracts deployed on the BlockChain . Their address is a unique identifier that can safely be used by service provider to identify their owner, and even to sign challenges like direct authentication on a website . Claims can be attached to prove compliance with a tokenized asset requirements. An InvestorID identity allows an investor to truly own its identity, whilst allowing trusted services to emit claims for it. The data associated with the identity and its claims are under the control of the investor who can share them with other service providers. They are fully compatible with every security token based on the T-REX standard (Token for Regulated EXchanges). What should be expected of this documentation? This documentation introduces the concept of a BlockChain Identity, and demonstrate some of its use-case. It also contains the documentation for several tools related to InvestorID Identities such as the Identity SDK .","title":"Introduction"},{"location":"introduction/#identity-ecosystem-for-digital-assets-holders","text":"","title":"Identity ecosystem for digital assets holders"},{"location":"introduction/#what-is-investorid","text":"InvestorID identities are smart contracts deployed on the BlockChain . Their address is a unique identifier that can safely be used by service provider to identify their owner, and even to sign challenges like direct authentication on a website . Claims can be attached to prove compliance with a tokenized asset requirements. An InvestorID identity allows an investor to truly own its identity, whilst allowing trusted services to emit claims for it. The data associated with the identity and its claims are under the control of the investor who can share them with other service providers. They are fully compatible with every security token based on the T-REX standard (Token for Regulated EXchanges).","title":"What is InvestorID?"},{"location":"introduction/#what-should-be-expected-of-this-documentation","text":"This documentation introduces the concept of a BlockChain Identity, and demonstrate some of its use-case. It also contains the documentation for several tools related to InvestorID Identities such as the Identity SDK .","title":"What should be expected of this documentation?"},{"location":"license/","text":"","title":"License"},{"location":"blockchain/core-concepts/","text":"","title":"Main concepts"},{"location":"developers/developers/","text":"Hello, World! Welcome developers! The InvestorID ecosystem comes with many tools and packages you can use to facilitate the integration of blockchain identities with your applications.","title":"Developers HomePage"},{"location":"developers/developers/#hello-world","text":"Welcome developers! The InvestorID ecosystem comes with many tools and packages you can use to facilitate the integration of blockchain identities with your applications.","title":"Hello, World!"},{"location":"developers/sdks/identity-sdk/blockchain-providers/","text":"BlockChain Provider It is recommended that you connect with a BlockChain Provider to retrieve information directly from the BlockChaim. If you don't intend to validate data with the BlockChain but to only use an Identity Provider, you can pass this step. The SDK is using Ethers to connect with Ethereum network. Thus, any provider supported by Ethers can be used with the SDK. This means any standard web3 provider should by supported. Connect to a default provider // You can use any standard network name // - \"homestead\" // - \"rinkeby\" // - \"ropsten\" // - \"kovan\" let provider = ethers . getDefaultProvider ( 'ropsten' ); let provider = ethers . getDefaultProvider ( 'homestead' ); Connect to JSON RPC // When using the JSON-RPC API, the network will be automatically detected // Default: http://localhost:8545 let httpProvider = new ethers . providers . JsonRpcProvider (); Connect to any Web3 Provider // When using a Web3 provider, the network will be automatically detected // e.g. HTTP provider let currentProvider = new web3 . providers . HttpProvider ( 'http://localhost:8545' ); let web3Provider = new ethers . providers . Web3Provider ( currentProvider ); Connect to MetaMask (for in-browser usage) // The network will be automatically detected; if the network is // changed in MetaMask, it causes a page refresh. let provider = new ethers . providers . Web3Provider ( web3 . currentProvider ); Please refer to the Ethers Providers Documentation for more information.","title":"BlockChain Providers"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#blockchain-provider","text":"It is recommended that you connect with a BlockChain Provider to retrieve information directly from the BlockChaim. If you don't intend to validate data with the BlockChain but to only use an Identity Provider, you can pass this step. The SDK is using Ethers to connect with Ethereum network. Thus, any provider supported by Ethers can be used with the SDK. This means any standard web3 provider should by supported.","title":"BlockChain Provider"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-a-default-provider","text":"// You can use any standard network name // - \"homestead\" // - \"rinkeby\" // - \"ropsten\" // - \"kovan\" let provider = ethers . getDefaultProvider ( 'ropsten' ); let provider = ethers . getDefaultProvider ( 'homestead' );","title":"Connect to a default provider"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-json-rpc","text":"// When using the JSON-RPC API, the network will be automatically detected // Default: http://localhost:8545 let httpProvider = new ethers . providers . JsonRpcProvider ();","title":"Connect to JSON RPC"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-any-web3-provider","text":"// When using a Web3 provider, the network will be automatically detected // e.g. HTTP provider let currentProvider = new web3 . providers . HttpProvider ( 'http://localhost:8545' ); let web3Provider = new ethers . providers . Web3Provider ( currentProvider );","title":"Connect to any Web3 Provider"},{"location":"developers/sdks/identity-sdk/blockchain-providers/#connect-to-metamask-for-in-browser-usage","text":"// The network will be automatically detected; if the network is // changed in MetaMask, it causes a page refresh. let provider = new ethers . providers . Web3Provider ( web3 . currentProvider ); Please refer to the Ethers Providers Documentation for more information.","title":"Connect to MetaMask (for in-browser usage)"},{"location":"developers/sdks/identity-sdk/configuration/","text":"Configuration Identity Providers By default, unsecured Identity Providers are not allowed. The SDK will refuse to fetch data on these endpoints. A claim that has an uri which is not an HTTPS endpoint won't be retrieved. Allow unsecured endpoints with: const IdentitySDK = require ( '@nakasar/identity-sdk' ); IdentitySDK . config ({ allowUnsecuredProviders : true });","title":"Configuration"},{"location":"developers/sdks/identity-sdk/configuration/#configuration","text":"","title":"Configuration"},{"location":"developers/sdks/identity-sdk/configuration/#identity-providers","text":"By default, unsecured Identity Providers are not allowed. The SDK will refuse to fetch data on these endpoints. A claim that has an uri which is not an HTTPS endpoint won't be retrieved. Allow unsecured endpoints with: const IdentitySDK = require ( '@nakasar/identity-sdk' ); IdentitySDK . config ({ allowUnsecuredProviders : true });","title":"Identity Providers"},{"location":"developers/sdks/identity-sdk/examples/","text":"Some example of usage Execute direct contract calls You can also call function from the smart contract using the Identity.instance property. const IdentitySDK = require ( '@investorid/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const claims = await identity . instance . getClaimIdsByType ( 1 ); console . log ( claims ); // Will return the unparsed response from the blockchain. }); All functions from the ERC734 and ERC735 standards will be callable, as well as all custom functions implemented in the T-REX standard . Get keys of an Identity const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const keys = await identity . getKeysByPurpose ( IdentitySDK . utils . enums . KeyPurpose . CLAIM ); console . log ( keys ); console . log ( await identity . getKeyPurpose ( keys [ 0 ]. key )); })(); Deploy an identity const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const PRIVATE_KEY = 'tokeny_private_key' ; const wallet = new Ethers . Wallet ( PRIVATE_KEY , provider ); ( async () => { // Deploy a new Identity, will await transaction confirmation. const identity = await IdentitySDK . Identity . deployNew ( wallet ); })(); Get details of a claim with an Claim Issuer const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); ( async () => { IdentitySDK . config ({ allowUnsecuredProviders : true }); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); const claims = await identity . getClaimsByType ( IdentitySDK . utils . enums . ClaimType . KYC ); const claim = new IdentitySDK . Claim ( claims [ 0 ]); await claim . populate (); // Will fetch public data of the claim from the claim URI. console . log ( claim ); /* Claim { data: '0x65773261724950755a302f626e5a744e327961676676376139462f6a3672744a4e3761666a52414c6871493d', id: '0x3c6532cc1f4d1a44de8f58d4bde617bef8e744168bf92d783a0e1b66e7c6a44a', issuer: '0x8c78fF753c63ea0e8CA1FcA9997A132bC3e6a8F1', scheme: 1, type: 1, uri: 'http://localhost:8080/claims/b701e350-2a08-11e9-ac7e-517ddf10b60e', issuanceDate: 2019-02-06T12:14:12.996Z, emissionDate: 2019-02-06T12:15:02.039Z, status: 'PENDING', publicData: { result: 'clear' } } */ })();","title":"Examples"},{"location":"developers/sdks/identity-sdk/examples/#some-example-of-usage","text":"","title":"Some example of usage"},{"location":"developers/sdks/identity-sdk/examples/#execute-direct-contract-calls","text":"You can also call function from the smart contract using the Identity.instance property. const IdentitySDK = require ( '@investorid/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const claims = await identity . instance . getClaimIdsByType ( 1 ); console . log ( claims ); // Will return the unparsed response from the blockchain. }); All functions from the ERC734 and ERC735 standards will be callable, as well as all custom functions implemented in the T-REX standard .","title":"Execute direct contract calls"},{"location":"developers/sdks/identity-sdk/examples/#get-keys-of-an-identity","text":"const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); ( async () => { const keys = await identity . getKeysByPurpose ( IdentitySDK . utils . enums . KeyPurpose . CLAIM ); console . log ( keys ); console . log ( await identity . getKeyPurpose ( keys [ 0 ]. key )); })();","title":"Get keys of an Identity"},{"location":"developers/sdks/identity-sdk/examples/#deploy-an-identity","text":"const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); const PRIVATE_KEY = 'tokeny_private_key' ; const wallet = new Ethers . Wallet ( PRIVATE_KEY , provider ); ( async () => { // Deploy a new Identity, will await transaction confirmation. const identity = await IdentitySDK . Identity . deployNew ( wallet ); })();","title":"Deploy an identity"},{"location":"developers/sdks/identity-sdk/examples/#get-details-of-a-claim-with-an-claim-issuer","text":"const IdentitySDK = require ( '@nakasar/identity-sdk' ); const Ethers = require ( 'ethers' ); const provider = Ethers . getDefaultProvider ( 'ropsten' ); ( async () => { IdentitySDK . config ({ allowUnsecuredProviders : true }); const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); const claims = await identity . getClaimsByType ( IdentitySDK . utils . enums . ClaimType . KYC ); const claim = new IdentitySDK . Claim ( claims [ 0 ]); await claim . populate (); // Will fetch public data of the claim from the claim URI. console . log ( claim ); /* Claim { data: '0x65773261724950755a302f626e5a744e327961676676376139462f6a3672744a4e3761666a52414c6871493d', id: '0x3c6532cc1f4d1a44de8f58d4bde617bef8e744168bf92d783a0e1b66e7c6a44a', issuer: '0x8c78fF753c63ea0e8CA1FcA9997A132bC3e6a8F1', scheme: 1, type: 1, uri: 'http://localhost:8080/claims/b701e350-2a08-11e9-ac7e-517ddf10b60e', issuanceDate: 2019-02-06T12:14:12.996Z, emissionDate: 2019-02-06T12:15:02.039Z, status: 'PENDING', publicData: { result: 'clear' } } */ })();","title":"Get details of a claim with an Claim Issuer"},{"location":"developers/sdks/identity-sdk/get-started/","text":"Get Started Installation Install with npm install @investorid/identity-sdk Then require with: const IdentitySDK = require ( '@investorid/identity-sdk' ); Load an Identity The unique identifier of an Identity is its address. To load its data from the BlockChain, you need to instantiate a connection with a BlockChain provider. In this documentation, the test network ropsten will be used. Replace by homestead to target main network (see the BlockChain Providers for more information on different type of network). const ethers = require ( 'ethers' ); const provider = ethers . getDefaultProvider ( 'ropsten' ); // instantiate an Identity from its address on a specific network. const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider ); Use SDK methods to retrieve data Once the identity is loaded from an address, you can call the methods from the Identity object. Here is a basic one that retrieves all claims of an identity by type. ( async () => { const claims = await identity . getClaimsByType ( 1 ); console . log ( claims ); // Will return the parsed claims of the identity. })();","title":"Get Started"},{"location":"developers/sdks/identity-sdk/get-started/#get-started","text":"","title":"Get Started"},{"location":"developers/sdks/identity-sdk/get-started/#installation","text":"Install with npm install @investorid/identity-sdk Then require with: const IdentitySDK = require ( '@investorid/identity-sdk' );","title":"Installation"},{"location":"developers/sdks/identity-sdk/get-started/#load-an-identity","text":"The unique identifier of an Identity is its address. To load its data from the BlockChain, you need to instantiate a connection with a BlockChain provider. In this documentation, the test network ropsten will be used. Replace by homestead to target main network (see the BlockChain Providers for more information on different type of network). const ethers = require ( 'ethers' ); const provider = ethers . getDefaultProvider ( 'ropsten' ); // instantiate an Identity from its address on a specific network. const identity = new IdentitySDK . Identity ( '0xadD92F8Ef0729E969c5a98Ea5740c9b644B362e3' , provider );","title":"Load an Identity"},{"location":"developers/sdks/identity-sdk/get-started/#use-sdk-methods-to-retrieve-data","text":"Once the identity is loaded from an address, you can call the methods from the Identity object. Here is a basic one that retrieves all claims of an identity by type. ( async () => { const claims = await identity . getClaimsByType ( 1 ); console . log ( claims ); // Will return the parsed claims of the identity. })();","title":"Use SDK methods to retrieve data"},{"location":"developers/sdks/identity-sdk/identity-sdk/","text":"The Identity SDK This package facilitates the interaction with Identities stored in the BlockChain. Forewords It is recommended you read the Identities section before continuing further. The JS Identity SDK targets server-side environments with a NodeJS Runtime. It is intended to work in-browser with web3 provider as well, but it was not built yet. It is intended to support any identity compliant with the ERC734 and ERC735 standards (which are still in draft state). It will work especially well with the contract implementations of the T-REX standard . Functionality Deploy identities List keys on an Identity. Manage keys on an Identity (if allowed). List Claims on an Identity. Manage Claims on an Identity (if allowed). Issue claims for an Identity (if allowed). Verify a claim (check validity). Fetch claim data using their URI. Request access to claim private data using their URI. Use access grants to access private data of claims.","title":"Home"},{"location":"developers/sdks/identity-sdk/identity-sdk/#the-identity-sdk","text":"This package facilitates the interaction with Identities stored in the BlockChain.","title":"The Identity SDK"},{"location":"developers/sdks/identity-sdk/identity-sdk/#forewords","text":"It is recommended you read the Identities section before continuing further. The JS Identity SDK targets server-side environments with a NodeJS Runtime. It is intended to work in-browser with web3 provider as well, but it was not built yet. It is intended to support any identity compliant with the ERC734 and ERC735 standards (which are still in draft state). It will work especially well with the contract implementations of the T-REX standard .","title":"Forewords"},{"location":"developers/sdks/identity-sdk/identity-sdk/#functionality","text":"Deploy identities List keys on an Identity. Manage keys on an Identity (if allowed). List Claims on an Identity. Manage Claims on an Identity (if allowed). Issue claims for an Identity (if allowed). Verify a claim (check validity). Fetch claim data using their URI. Request access to claim private data using their URI. Use access grants to access private data of claims.","title":"Functionality"},{"location":"developers/sdks/identity-sdk/signer-module/","text":"SignerModule Many interaction with identities, and especially accessing claims, require to sign a challenge message. Functions requiring these signatures expect a SignerModule as argument. A SignerModule must expose a .getPublicKey() and a .signMessage(message: string) functions. This, for instance, id a valid simple SignerModule: const jsrasign = require ( 'jsrasign' ); const signer = { getPublicKey : async () => ({ key : \"-----BEGIN CERTIFICATE----- my_super_public_key -----END CERTIFICATE-----\" , type : \"X.509\" , signingMethod : \"SHA-256\" , }), signMessage : async ( message ) => { const signer = new jsrsasign . Signature ({ alg : 'SHA256withRSA' }); signer . init ( \"-----BEGIN CERTIFICATE----- my_super_PRIVATE_no_really_super_secret_PRIVATE_key -----END CERTIFICATE-----\" ); signer . updateString ( message ); return signer . sign (); }, }; It can be used in functions such as Claim.requestAccess(): claim . requestAccess ( IdentitySDK . utils . enums . AccessGrantType . PERSISTENT , signer );","title":"Signing Challenges"},{"location":"developers/sdks/identity-sdk/signer-module/#signermodule","text":"Many interaction with identities, and especially accessing claims, require to sign a challenge message. Functions requiring these signatures expect a SignerModule as argument. A SignerModule must expose a .getPublicKey() and a .signMessage(message: string) functions. This, for instance, id a valid simple SignerModule: const jsrasign = require ( 'jsrasign' ); const signer = { getPublicKey : async () => ({ key : \"-----BEGIN CERTIFICATE----- my_super_public_key -----END CERTIFICATE-----\" , type : \"X.509\" , signingMethod : \"SHA-256\" , }), signMessage : async ( message ) => { const signer = new jsrsasign . Signature ({ alg : 'SHA256withRSA' }); signer . init ( \"-----BEGIN CERTIFICATE----- my_super_PRIVATE_no_really_super_secret_PRIVATE_key -----END CERTIFICATE-----\" ); signer . updateString ( message ); return signer . sign (); }, }; It can be used in functions such as Claim.requestAccess(): claim . requestAccess ( IdentitySDK . utils . enums . AccessGrantType . PERSISTENT , signer );","title":"SignerModule"},{"location":"identities/claims/","text":"","title":"Claims"},{"location":"identities/connect-with-identity/","text":"","title":"Connect with your Identity"},{"location":"identities/grants/","text":"","title":"Controlling your data"},{"location":"identities/information/","text":"","title":"Basic Information"},{"location":"identities/introduction/","text":"","title":"What is an Identity"}]}